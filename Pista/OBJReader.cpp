#include "OBJReader.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include "MTLReader.h"
#include <iomanip>

OBJReader::OBJReader()
{
}



OBJReader::~OBJReader()
{
}

Mesh * OBJReader::read(std::string path)
{
	Mesh* mesh = new Mesh;
	std::ifstream arq(path);
	Group* currentGroup = nullptr;
	std::string currentMaterial;

	if (!arq.is_open()) {
		std::cout << "File could not be loaded. Wrong path!" << std::endl;
	}

	while (!arq.eof()) {
		std::string line;
		getline(arq, line);
		std::stringstream sline;
		sline << line;
		std::string temp;
		sline >> temp;
		if (temp == "v") {
			float x, y, z;
			sline >> x >> y >> z;
			mesh->setVertex(glm::vec3(x, y, z));

		}
		else if (temp == "vt") {
			float s, t;
			sline >> s >> t;
			mesh->setMappings(glm::vec2(s, t));
		}
		else if (temp == "vn") {
			float x, y, z;
			sline >> x >> y >> z;
			mesh->setNormals(glm::vec3(x, y, z));
		}
		else if (temp == "f") {
			Face face;
			Face newFace;
			int fourVertsCounter = 0;
			while (!sline.eof()) {
				fourVertsCounter++;
				std::string token;
				sline >> token;
				std::stringstream stoken;
				stoken << token;
				std::string auxV;
				std::string auxT;
				std::string auxN;

				std::getline(stoken, auxV, '/');
				std::getline(stoken, auxT, '/');
				std::getline(stoken, auxN, '/');

				if (fourVertsCounter == 4) {
					newFace.setVertex(face.getVertex()->at(2));
					newFace.setVertex(atoi(auxV.c_str()));
					newFace.setVertex(face.getVertex()->at(0));

					if (face.getTexts()->size() > 0) {
						newFace.setTexts(face.getTexts()->at(2));
						newFace.setTexts(atoi(auxT.c_str()));
						newFace.setTexts(face.getTexts()->at(0));
					}
					if (face.getNormals()->size() > 0) {
						newFace.setNormals(face.getNormals()->at(2));
						newFace.setNormals(atoi(auxN.c_str()));
						newFace.setNormals(face.getNormals()->at(0));
					}
				}
				else {
					face.setVertex(atoi(auxV.c_str()));

					if (auxT != "") {
						face.setTexts(atoi(auxT.c_str()));
					}

					if (auxN != "") {
						face.setNormals(atoi(auxN.c_str()));
					}
				}
			}
			if (currentGroup == nullptr) {
				Group* group = new Group();
				group->name = "default";
				currentGroup = group;
				mesh->setGroups(currentGroup);
			}
			currentGroup->faces.push_back(face);
			if (fourVertsCounter == 4) {
				currentGroup->faces.push_back(newFace);
			}
		}
		else if (temp == "g") {
			std::string name;
			std::string tempName;
			while (!sline.eof()) {
				sline >> tempName;
				name += tempName;
			}

			bool foundGroup = false;
			for (Group* g : *mesh->getGroups()) {
				if (name == g->name) {
					currentGroup = g;
					foundGroup = true;
					break;
				}
			}
			if (!foundGroup) {
				Group* group = new Group();
				group->name = name;
				currentGroup = group;
				currentGroup->material = currentMaterial;
				mesh->getGroups()->push_back(currentGroup);
			}
		}
		else if (temp == "mtllib") {
			std::string materialPath;
			sline >> materialPath;
			std::stringstream sPath;
			sPath << path;
			std::string auxPath;
			std::getline(sPath, auxPath, '/');
			mesh->materials = MTLReader::read(auxPath + "/" + materialPath);
		}
		else if (temp == "usemtl") {
			std::string materialName;
			sline >> materialName;
			if (currentGroup == nullptr) {
				Group* group = new Group();
				group->name = "default";
				currentGroup = group;
				mesh->setGroups(currentGroup);
			}
			currentGroup->material = materialName;
			currentMaterial = materialName;
		}
	}

	arq.close();
	return mesh;
}

void OBJReader::write(std::string path, Mesh* mesh) {
	std::ofstream file;
	file.exceptions(std::ofstream::badbit);

	try {
		file.open(path, std::ios::out);

		if (!file.is_open()) {
			throw std::runtime_error("ERROR::OBJREADER::PATH ERROR");
		}

		bool foundName = false;
		std::string meshName = "";
		int nameI = 0;
		while (!foundName) {
			char c = path[nameI];
			if (c == '/' || c == '\\') {
				meshName = "";
			}
			else if (c == '\0' || c == '\n' || c == '\r') {
				foundName = true;
			}
			else {
				meshName += c;
			}
			nameI++;
		}
		meshName.erase(meshName.end() - 4, meshName.end());

		// Header
		file << "# Generated by obj-loader \n\n";

		// MTL
		file << "mtllib " << meshName << ".mtl \n\n";
		std::string mtlName = meshName + ".mtl";
		MTLReader::write(mtlName.c_str(), &mesh->materials);

		// Vertices
		file << "# Vertexes \n";
		std::vector<glm::vec3>* vertexes = mesh->getVertex();
		size_t vertexesSize = vertexes->size();
		for (size_t i = 0; i < vertexesSize; i++) {
			file << "v " << std::fixed << std::setprecision(6) << (*vertexes)[i].x << " " << (*vertexes)[i].z << " " << (*vertexes)[i].y << '\n';
		}

		// Normal
		file << "# Normals \n";
		std::vector<glm::vec3>* normals = mesh->getNormals();
		size_t normalSize = normals->size();
		if (normalSize != 0) {
			for (size_t i = 0; i < normalSize; i++) {
				file << "vn " << std::fixed << std::setprecision(6) << (*normals)[i].x << " " << (*normals)[i].y << " " << (*normals)[i].z << '\n';
			}
		}

		// UV
		file << "# UV Mapping \n";
		std::vector<glm::vec2>* mappings = mesh->getMappings();
		size_t mappingSize = mappings->size();
		for (size_t i = 0; i < mappingSize; i++) {
			file << "vt " << std::fixed << std::setprecision(6) << (*mappings)[i].s << " " << (*mappings)[i].t << '\n';
		}

		// Groups
		file << "\n # Groups \n";

		std::vector<Group*>* groups = mesh->getGroups();
		size_t groupsSize = groups->size();

		for (size_t i = 0; i < groupsSize; i++) {

			// Group Name
			file << "g " << (*groups)[i]->name << '\n';

			// Material Name
			file << "usemtl " << (*groups)[i]->material << '\n';

			file << "\n # Faces \n";
			// Faces
			std::vector<Face> faces = (*groups)[i]->faces;
			size_t facesSize = faces.size();
			for (size_t f = 0; f < facesSize; f++)
			{
				std::vector<int>* verts = faces[f].getVertex();
				std::vector<int>* norms = faces[f].getNormals();
				std::vector<int>* mapps = faces[f].getTexts();

				bool hasNorms = false;
				bool hasMapps = false;

				if (norms->size()) {
					hasNorms = true;
				}
				if (mapps->size()) {
					hasMapps = true;
				}

				file << "f";

				size_t vSize = verts->size();
				for (size_t v = 0; v < vSize; v++)
				{

					file << ' ';

					file << (*verts)[v] << '/';

					if (hasMapps) {
						file << (*mapps)[v];
					}

					file << '/';

					if (hasNorms) {
						file << (*norms)[v];
					}
				}

				file << '\n';
			}

		}

	}
	catch (const std::ofstream::failure& e) {

		if (!file.eof()) {
			std::cout << "ERROR::OBJREADER::FILE NOT SUCCESUFULLY WRITTEN" << std::endl;
			file.close();
		}

	}
	catch (std::exception& e) {
		std::cout << e.what() << std::endl;
		file.close();
	}

	file.close();
};
